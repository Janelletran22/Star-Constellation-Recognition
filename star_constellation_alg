import os
import yaml
from ultralytics import YOLO
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import torch
from tqdm import tqdm

# Configuration
DATASET_PATH = "stars_constellations_dataset"  # Path to dataset
IMG_SIZE = 640  # Target image size
BATCH_SIZE = 16
EPOCHS = 1
LEARNING_RATE = 0.0005
MODEL_TYPE = "yolov8s.pt"  # Using the small variant (11.2M parameters)

# Define constellation classes (16 classes as per requirements)
CLASSES = [
    "Aquila", "Bootes", "Canis Major", "Canis Minor", "Cassiopeia",
    "Cygnus", "Gemini", "Leo", "Lyra", "Moon", 
    "Orion", "Pleiades", "Sagittarius", "Taurus", "Ursa Major", "Moon"
]

def create_dataset_structure():
    """
    Create the necessary directory structure for YOLOv8 format
    """
    os.makedirs(f"{DATASET_PATH}/images/train", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/images/val", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/images/test", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/labels/train", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/labels/val", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/labels/test", exist_ok=True)
    
    return

def preprocess_images(input_dir, output_dir, augment=True):
    """
    Enhanced image preprocessing function with advanced techniques for constellation detection
    
    Parameters:
    -----------
    input_dir : str
        Directory containing input images
    output_dir : str
        Directory to save processed images
    augment : bool
        Whether to apply data augmentation (default: True)
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Get all image files
    image_files = [f for f in os.listdir(input_dir) if f.endswith(('.jpg', '.png', '.jpeg', '.tif', '.tiff'))]
    
    for img_file in tqdm(image_files, desc="Preprocessing images"):
        img_path = os.path.join(input_dir, img_file)
        
        # Read image and handle errors
        img = cv2.imread(img_path)
        if img is None:
            print(f"Failed to load image: {img_path}")
            continue
        
        # Convert to RGB (YOLOv8 works with RGB)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        
        # Noise reduction (adaptive to preserve star details)
        # Use Non-local Means Denoising which preserves edges and fine details
        img = cv2.fastNlMeansDenoisingColored(img, None, 10, 10, 7, 21)
        
        # Contrast Limited Adaptive Histogram Equalization (CLAHE)
        # This enhances contrast while preventing noise amplification
        lab = cv2.cvtColor(img, cv2.COLOR_RGB2LAB)
        l, a, b = cv2.split(lab)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        l = clahe.apply(l)
        lab = cv2.merge((l, a, b))
        img = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)
        
        # Resize to square 640x640 with proper interpolation
        img_resized = cv2.resize(img, (IMG_SIZE, IMG_SIZE), interpolation=cv2.INTER_AREA)
        
        # Save the preprocessed image (RGB to BGR for OpenCV saving)
        output_path = os.path.join(output_dir, img_file)
        cv2.imwrite(output_path, cv2.cvtColor(img_resized, cv2.COLOR_RGB2BGR))
        
        # Perform data augmentation if enabled
        if augment:
            # Create augmented versions with varying brightness/contrast
            # This is especially important for astronomical imagery
            
            # 1. Brightness variation (simulates different exposure times)
            for brightness in [0.8, 1.2]:
                bright_img = np.clip(img_resized * brightness, 0, 255).astype(np.uint8)
                bright_path = os.path.join(output_dir, f"bright_{brightness}_{img_file}")
                cv2.imwrite(bright_path, cv2.cvtColor(bright_img, cv2.COLOR_RGB2BGR))
                
            # 2. Rotation (simulates camera rotation in night sky photography)
            for angle in [90, 180, 270]:
                height, width = img_resized.shape[:2]
                matrix = cv2.getRotationMatrix2D((width/2, height/2), angle, 1)
                rotated = cv2.warpAffine(img_resized, matrix, (width, height))
                rot_path = os.path.join(output_dir, f"rot_{angle}_{img_file}")
                cv2.imwrite(rot_path, cv2.cvtColor(rotated, cv2.COLOR_RGB2BGR))
                
            # 3. Add simulated noise (realistic for astronomical imagery)
            noise_img = img_resized.copy()
            noise = np.random.normal(0, 5, noise_img.shape).astype(np.uint8)
            noise_img = np.clip(noise_img + noise, 0, 255).astype(np.uint8)
            noise_path = os.path.join(output_dir, f"noise_{img_file}")
            cv2.imwrite(noise_path, cv2.cvtColor(noise_img, cv2.COLOR_RGB2BGR))
            
            # 4. Vertical flip (valid astronomical transformation)
            flipped = cv2.flip(img_resized, 0)
            flip_path = os.path.join(output_dir, f"flip_{img_file}")
            cv2.imwrite(flip_path, cv2.cvtColor(flipped, cv2.COLOR_RGB2BGR))
            
    return

def split_dataset(image_list, labels_list, train_ratio=0.7, val_ratio=0.2, test_ratio=0.1):
    """
    Split dataset into train, validation and test sets based on specified ratio
    """
    # First split into train and temporary sets
    train_images, temp_images, train_labels, temp_labels = train_test_split(
        image_list, labels_list, test_size=(val_ratio + test_ratio), random_state=42
    )
    
    # Split temporary set into validation and test sets
    val_ratio_adjusted = val_ratio / (val_ratio + test_ratio)
    val_images, test_images, val_labels, test_labels = train_test_split(
        temp_images, temp_labels, test_size=(1 - val_ratio_adjusted), random_state=42
    )
    
    return (train_images, train_labels), (val_images, val_labels), (test_images, test_labels)

def create_yaml_config():
    """
    Create YAML configuration file for YOLOv8 training
    """
    config = {
        'path': os.path.abspath(DATASET_PATH),
        'train': 'images/train',
        'val': 'images/val',
        'test': 'images/test',
        'names': {i: name for i, name in enumerate(CLASSES)}
    }
    
    with open(f"{DATASET_PATH}/constellation_data.yaml", 'w') as f:
        yaml.dump(config, f, default_flow_style=False)
    
    print(f"Created YAML configuration at {DATASET_PATH}/constellation_data.yaml")
    return f"{DATASET_PATH}/constellation_data.yaml"

def train_model(yaml_path):
    """
    Train the YOLOv8s model using the dataset
    """
    # Load a pretrained YOLOv8s model
    model = YOLO(MODEL_TYPE)
    
    # Train the model
    results = model.train(
        data=yaml_path,
        epochs=EPOCHS,
        batch=BATCH_SIZE,
        imgsz=IMG_SIZE,
        optimizer="Adam",  # As per requirements
        lr0=LEARNING_RATE,  # Initial learning rate
        conf=0.25,  # Detection confidence threshold
        name="constellation_detector",
        device=0 if torch.cuda.is_available() else 'cpu'
    )
    
    return model, results

def evaluate_model(model):
    """
    Evaluate model performance using mAP50 and other metrics
    """
    # Validate the model
    results = model.val(conf=0.1)
    
    # Handle potentially multi-element arrays by taking the first element if needed
    def safe_convert(value):
        try:
            # Try direct conversion first
            return float(value)
        except (TypeError, ValueError):
            # If that fails, try to access the first element
            if hasattr(value, '__len__') and len(value) > 0:
                return float(value[0])
            # If that also fails, return a default value
            return 0.0
    
    metrics = {
        "mAP50": safe_convert(results.box.map50),
        "precision": safe_convert(results.box.p),
        "recall": safe_convert(results.box.r),
        "f1": safe_convert(results.box.f1)
    }
    
    print("\nEvaluation Metrics:")
    print(f"mAP50: {metrics['mAP50']:.4f}")
    print(f"Precision: {metrics['precision']:.4f}")
    print(f"Recall: {metrics['recall']:.4f}")
    print(f"F1 Score: {metrics['f1']:.4f}")
    
    return metrics

def detect_constellations(model, image_path):
    """
    Perform constellation detection on a single image
    """
    # Run inference
    results = model.predict(image_path, conf=0.25)
    
    # Process results
    result = results[0]
    image = cv2.imread(image_path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    
    # Display results
    plt.figure(figsize=(10, 10))
    plt.imshow(result.plot())
    plt.axis('off')
    plt.title('Constellation Detection')
    plt.show()
    
    # Print detections
    for box in result.boxes:
        class_id = int(box.cls[0].item())
        confidence = box.conf[0].item()
        coordinates = box.xyxy[0].tolist()
        print(f"Detected {CLASSES[class_id]} with confidence {confidence:.2f} at {coordinates}")
    
    return result

def main():
    """
    Main function to run the constellation detection pipeline with preprocessing
    """
    # Step 1: Preprocess images
    print("Preprocessing and augmenting images...")
    
    # Define raw and processed directories based on existing structure
    raw_images_dir = "stars_constellations_dataset/images"  # Base directory containing your images
    processed_images_dir = "stars_constellations_dataset/preprocessed_images"  # New directory for processed images
    
    # Create preprocessed images directory structure
    os.makedirs(f"{processed_images_dir}/train", exist_ok=True)
    os.makedirs(f"{processed_images_dir}/val", exist_ok=True)
    os.makedirs(f"{processed_images_dir}/test", exist_ok=True)
    
    # Preprocess and augment training images
    print("Processing training images...")
    preprocess_images(
        input_dir=f"{raw_images_dir}/train", 
        output_dir=f"{processed_images_dir}/train",
        augment=True
    )
    
    # Preprocess validation images (no augmentation)
    print("Processing validation images...")
    preprocess_images(
        input_dir=f"{raw_images_dir}/val", 
        output_dir=f"{processed_images_dir}/val",
        augment=False
    )
    
    # Preprocess test images (no augmentation)
    print("Processing test images...")
    preprocess_images(
        input_dir=f"{raw_images_dir}/test", 
        output_dir=f"{processed_images_dir}/test",
        augment=False
    )
    
    # Step 2: Update or create YAML configuration for the preprocessed images
    yaml_path = f"{DATASET_PATH}/constellation_data.yaml"
    
    # Check if the YAML file already exists
    if os.path.exists(yaml_path):
        print(f"YAML configuration found at {yaml_path}, updating...")
        with open(yaml_path, 'r') as f:
            config = yaml.safe_load(f)
    else:
        print(f"Creating new YAML configuration at {yaml_path}...")
        config = {
            'path': os.path.abspath(DATASET_PATH),
            'names': {i: name for i, name in enumerate(CLASSES)}
        }
    
    # Update paths to use preprocessed images
    config['train'] = 'preprocessed_images/train'
    config['val'] = 'preprocessed_images/val' 
    config['test'] = 'preprocessed_images/test'
    
    # Save updated config
    with open(yaml_path, 'w') as f:
        yaml.dump(config, f, default_flow_style=False)
    
    print(f"Updated YAML configuration at {yaml_path}")
    
    # Step 3: Train the model
    print("Training YOLOv8s model...")
    model, training_results = train_model(yaml_path)
    
    # Step 4: Evaluate the model
    print("Evaluating model performance...")
    metrics = evaluate_model(model)
    
    # Save the trained model
    model_save_path = "models/constellation_detector_yolov8s.pt"
    os.makedirs(os.path.dirname(model_save_path), exist_ok=True)
    model.save(model_save_path)
    print(f"Model saved to {model_save_path}")
    
    # Step 5: Optional - Test with a sample image
    test_images = os.listdir(f"{raw_images_dir}/test")
    if test_images:
        sample_image = os.path.join(f"{raw_images_dir}/test", test_images[0])
        print(f"Running inference on sample image: {sample_image}")
        detect_constellations(model, sample_image)
    
    print("Constellation detection model training and evaluation complete!")

if __name__ == "__main__":
    main()
