import os
import yaml
from ultralytics import YOLO
import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import torch
from tqdm import tqdm

# Configuration
DATASET_PATH = "stars_constellations_dataset"  # Path to dataset
IMG_SIZE = 640  # Target image size
BATCH_SIZE = 16
EPOCHS = 1
LEARNING_RATE = 0.0005
MODEL_TYPE = "yolov8s.pt"  # Using the small variant (11.2M parameters)

# Define constellation classes (16 classes as per requirements)
CLASSES = [
    "Aquila", "Bootes", "Canis Major", "Canis Minor", "Cassiopeia",
    "Cygnus", "Gemini", "Leo", "Lyra", "Moon", 
    "Orion", "Pleiades", "Sagittarius", "Taurus", "Ursa Major", "Moon"
]

def create_dataset_structure():
    """
    Create the necessary directory structure for YOLOv8 format
    """
    os.makedirs(f"{DATASET_PATH}/images/train", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/images/val", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/images/test", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/labels/train", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/labels/val", exist_ok=True)
    os.makedirs(f"{DATASET_PATH}/labels/test", exist_ok=True)
    
    return

def preprocess_images(input_dir, output_dir):
    """
    Preprocess images by resizing to 640x640 as per requirements
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    image_files = [f for f in os.listdir(input_dir) if f.endswith(('.jpg', '.png', '.jpeg'))]
    
    for img_file in tqdm(image_files, desc="Preprocessing images"):
        img_path = os.path.join(input_dir, img_file)
        img = cv2.imread(img_path)
        
        # Check if image loaded correctly
        if img is None:
            print(f"Failed to load image: {img_path}")
            continue
        
        # Resize to square 640x640
        img_resized = cv2.resize(img, (IMG_SIZE, IMG_SIZE))
        
        # Save the preprocessed image
        output_path = os.path.join(output_dir, img_file)
        cv2.imwrite(output_path, img_resized)
    
    return

def split_dataset(image_list, labels_list, train_ratio=0.7, val_ratio=0.2, test_ratio=0.1):
    """
    Split dataset into train, validation and test sets based on specified ratio
    """
    # First split into train and temporary sets
    train_images, temp_images, train_labels, temp_labels = train_test_split(
        image_list, labels_list, test_size=(val_ratio + test_ratio), random_state=42
    )
    
    # Split temporary set into validation and test sets
    val_ratio_adjusted = val_ratio / (val_ratio + test_ratio)
    val_images, test_images, val_labels, test_labels = train_test_split(
        temp_images, temp_labels, test_size=(1 - val_ratio_adjusted), random_state=42
    )
    
    return (train_images, train_labels), (val_images, val_labels), (test_images, test_labels)

def create_yaml_config():
    """
    Create YAML configuration file for YOLOv8 training
    """
    config = {
        'path': os.path.abspath(DATASET_PATH),
        'train': 'images/train',
        'val': 'images/val',
        'test': 'images/test',
        'names': {i: name for i, name in enumerate(CLASSES)}
    }
    
    with open(f"{DATASET_PATH}/constellation_data.yaml", 'w') as f:
        yaml.dump(config, f, default_flow_style=False)
    
    print(f"Created YAML configuration at {DATASET_PATH}/constellation_data.yaml")
    return f"{DATASET_PATH}/constellation_data.yaml"

def train_model(yaml_path):
    """
    Train the YOLOv8s model using the dataset
    """
    # Load a pretrained YOLOv8s model
    model = YOLO(MODEL_TYPE)
    
    # Train the model
    results = model.train(
        data=yaml_path,
        epochs=EPOCHS,
        batch=BATCH_SIZE,
        imgsz=IMG_SIZE,
        optimizer="Adam",  # As per requirements
        lr0=LEARNING_RATE,  # Initial learning rate
        conf=0.25,  # Detection confidence threshold
        name="constellation_detector",
        device=0 if torch.cuda.is_available() else 'cpu'
    )
    
    return model, results

def evaluate_model(model):
    """
    Evaluate model performance using mAP50 and other metrics
    """
    # Validate the model
    results = model.val(conf=0.1)
    
    # Handle potentially multi-element arrays by taking the first element if needed
    def safe_convert(value):
        try:
            # Try direct conversion first
            return float(value)
        except (TypeError, ValueError):
            # If that fails, try to access the first element
            if hasattr(value, '__len__') and len(value) > 0:
                return float(value[0])
            # If that also fails, return a default value
            return 0.0
    
    metrics = {
        "mAP50": safe_convert(results.box.map50),
        "precision": safe_convert(results.box.p),
        "recall": safe_convert(results.box.r),
        "f1": safe_convert(results.box.f1)
    }
    
    print("\nEvaluation Metrics:")
    print(f"mAP50: {metrics['mAP50']:.4f}")
    print(f"Precision: {metrics['precision']:.4f}")
    print(f"Recall: {metrics['recall']:.4f}")
    print(f"F1 Score: {metrics['f1']:.4f}")
    
    return metrics

def detect_constellations(model, image_path):
    """
    Perform constellation detection on a single image
    """
    # Run inference
    results = model.predict(image_path, conf=0.25)
    
    # Process results
    result = results[0]
    image = cv2.imread(image_path)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    
    # Display results
    plt.figure(figsize=(10, 10))
    plt.imshow(result.plot())
    plt.axis('off')
    plt.title('Constellation Detection')
    plt.show()
    
    # Print detections
    for box in result.boxes:
        class_id = int(box.cls[0].item())
        confidence = box.conf[0].item()
        coordinates = box.xyxy[0].tolist()
        print(f"Detected {CLASSES[class_id]} with confidence {confidence:.2f} at {coordinates}")
    
    return result

def main():
    # Step 1: Create dataset structure
    create_dataset_structure()
    
    # Note: At this point you would need to:
    # 1. Collect/prepare your 1,750 labeled constellation images
    # 2. Convert annotations to YOLO format
    # 3. Place images and labels in the appropriate directories
    print("Please prepare your dataset by placing images and labels in the appropriate directories")
    
    # Step 2: Create YAML configuration
    yaml_path = create_yaml_config()
    
    # Step 3: Train the model
    print("Training YOLOv8s model...")
    model, training_results = train_model(yaml_path)
    
    # Step 4: Evaluate the model
    print("Evaluating model performance...")
    metrics = evaluate_model(model)
    
    # Save the trained model
    model_save_path = "models/constellation_detector_yolov8s.pt"
    os.makedirs(os.path.dirname(model_save_path), exist_ok=True)
    model.save(model_save_path)
    print(f"Model saved to {model_save_path}")
    
    # For demonstration, you would use your own test image
    # detect_constellations(model, "path_to_test_image.jpg")
    
    print("Constellation detection model training and evaluation complete!")

if __name__ == "__main__":
    main()
